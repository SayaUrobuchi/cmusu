---
layout: post
title:  "中國語標題．絕讚測試中♪"
date:   2016-06-22 00:30:15 +0900
categories: jekyll update
---
You’ll find this post in your `_posts` directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run `jekyll serve`, which launches a web server and auto-regenerates your site when a file is updated.

To add new posts, simply add a file in the `_posts` directory that follows the convention `YYYY-MM-DD-name-of-post.ext` and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.

Jekyll also offers powerful support for code snippets:

**1232354893570946789402678940267589467594**

{% highlight ruby %}
def print_hi(name)
  puts "Hi, #{name}"
end
print_hi('Tom')
#=> prints 'Hi, Tom' to STDOUT.
{% endhighlight %}

{% highlight javascript linenos %}

function Action(id, caster, is_preview)
{
	var self = {};
	group = caster.group || GROUP.NONE;
	
	self.init = function ()
	{
		self.caster = caster;
		self.card_id = id;
		self.data = CARD[id];
		self.group = group;
		self.speed = self.data.speed;
		self.name = self.data.name;
		self.cost = self.data.cost;
		self.is_preview = is_preview;
	}
	
	self.compare_to = function (action)
	{
		if (self.speed != action.speed)
		{
			return self.speed - action.speed;
		}
		return action.group - self.group;
	}
	
	self.is_available = function (field)
	{
		return self.caster.can_act(field) && self.target.length > 0;
	}
	
	self.prepare = function (field)
	{
		self.get_target(field);
		self.is_finished = false;
	}
	
	self.start = function (field)
	{
		if (self.target.length > 0)
		{
			self.power = [];
			for (var i=0; i<self.data.effect.length; i++)
			{
				var list = [];
				for (var j=0; j<self.target[i].length; j++)
				{
					list.push(self.calc_power(field, self.data.effect[i], self.target[i][j]));
				}
				self.power.push(list);
			}
		}
		self.fcnt = 0;
		self.wait = -1;
		self.eidx = 0;
		self.tidx = -1;
	}
	
	self.execute = function (field)
	{
		if (!self.caster.can_act(field) || self.target.length <= 0)
		{
			self.is_finished = true;
			return;
		}
		if (self.caster.is_casting(field))
		{
			return;
		}
		if (self.fcnt <= 0)
		{
			self.caster.cast_animation(field, self);
		}
		else if (self.fcnt > self.wait)
		{
			self.tidx++;
			if (self.tidx >= self.target[self.eidx].length)
			{
				self.eidx++;
				self.tidx = 0;
				self.wait = self.fcnt + 15;
				if (self.eidx >= self.data.effect.length)
				{
					self.is_finished = true;
					return;
				}
			}
			else
			{
				self.wait = self.fcnt + 15;
			}
			self.execute_effect(field, self.data.effect[self.eidx], 
				self.target[self.eidx][self.tidx], self.power[self.eidx][self.tidx]);
		}
		self.fcnt++;
	}
	
	self.execute_effect = function (field, effect, target, power)
	{
		switch (effect.type)
		{
		case EFFECT.DAMAGE:
			target.take_damage(field, power);
			break;
		case EFFECT.HEAL:
			target.heal(field, power);
			break;
		}
	}
	
	self.get_target = function (field)
	{
		self.target = [];
		for (var i=0; i<self.data.effect.length; i++)
		{
			self.target.push(field.get_target(self.data.effect[i], self.caster, self.group));
		}
	}
	
	self.calc_power = function (field, effect, target)
	{
		var power = 0;
		if (effect.atk)
		{
			power += self.caster.atk * effect.atk / 100;
		}
		if (effect.hp)
		{
			power += target.hp * effect.hp / 100;
		}
		if (effect.mhp)
		{
			power += target.mhp * effect.mhp / 100;
		}
		return Math.floor(power * (1+field.get_chain_bonus()));
	}
	
	self.is_finish = function ()
	{
		return self.is_finished;
	}
	
	self.init();
	
	return self;
}

{% endhighlight %}

{% highlight c linenos %}
#include <stdio.h>
#include <string.h>

#define EMPTY 0
#define BLACK 1
#define WHITE 2

int hash[128];
int wayx[8] = {0, 1, 0, -1, 1, 1, -1, -1};
int wayy[8] = {1, 0, -1, 0, 1, -1, 1, -1};
int qx[80], qy[80];
char board[8][9], chess[4]={"-BW"};
char buf[2008];

int valid(int x, int y)
{
	return x >= 0 && x < 8 && y >= 0 && y < 8;
}

int main()
{
	int count, i, j, k, q, b, w, c, f, x, y, tx, ty, turn;
	hash['-'] = EMPTY;
	hash['W'] = WHITE;
	hash['B'] = BLACK;
	scanf("%d", &count);
	while(count--)
	{
		for(i=0, b=w=0; i<8; i++)
		{
			scanf("%s", board[i]);
			for(j=0; j<8; j++)
			{
				if(board[i][j] == 'W')
				{
					w++;
				}
				else if(board[i][j] == 'B')
				{
					b++;
				}
			}
		}
		scanf("%s", buf);
		turn = hash[buf[0]];
		while(scanf("%s", buf) == 1)
		{
			if(!strcmp(buf, "Q"))
			{
				for(i=0; i<8; i++)
				{
					puts(board[i]);
				}
				break;
			}
			else if(!strcmp(buf, "L"))
			{
				for(i=0, q=0; i<8; i++)
				{
					for(j=0; j<8; j++)
					{
						if(board[i][j] == '-')
						{
							for(k=0; k<8; k++)
							{
								for(x=i, y=j, c=0; ; )
								{
									x += wayx[k];
									y += wayy[k];
									if(valid(x, y))
									{
										if(hash[board[x][y]] == EMPTY)
										{
											c = 0;
											break;
										}
										else if(hash[board[x][y]] == turn)
										{
											break;
										}
										c++;
									}
									else
									{
										c = 0;
										break;
									}
								}
								if(c)
								{
									break;
								}
							}
							if(k < 8)
							{
								qx[q] = i+1;
								qy[q] = j+1;
								q++;
							}
						}
					}
				}
				if(q)
				{
					printf("(%d,%d)", qx[0], qy[0]);
					for(i=1; i<q; i++)
					{
						printf(" (%d,%d)", qx[i], qy[i]);
					}
					printf("\n");
				}
				else
				{
					printf("No legal move.\n");
				}
			}
			else
			{
				x = buf[1] - '1';
				y = buf[2] - '1';
				for(f=0; ; turn=3-turn)
				{
					for(k=0; k<8; k++)
					{
						for(tx=x, ty=y, c=0; ; )
						{
							tx += wayx[k];
							ty += wayy[k];
							if(valid(tx, ty))
							{
								if(board[tx][ty] == '-')
								{
									c = 0;
									break;
								}
								else if(hash[board[tx][ty]] == turn)
								{
									break;
								}
								qx[c] = tx;
								qy[c] = ty;
								c++;
							}
							else
							{
								c = 0;
								break;
							}
						}
						if(c)
						{
							f = 1;
							for(i=0; i<c; i++)
							{
								/*printf("XDD %d %d %c\n", qx[i], qy[i], chess[turn]);*/
								board[qx[i]][qy[i]] = chess[turn];
								if(turn == BLACK)
								{
									b++;
									w--;
								}
								else
								{
									b--;
									w++;
								}
							}
						}
					}
					if(f)
					{
						if(turn == BLACK)
						{
							b++;
						}
						else
						{
							w++;
						}
						board[x][y] = chess[turn];
						turn = 3 - turn;
						break;
					}
				}
				printf("Black - %2d White - %2d\n", b, w);
			}
		}
		if(count)
		{
			printf("\n");
		}
	}
	return 0;
}

{% endhighlight %}

Check out the [Jekyll docs][jekyll-docs] for more info on how to get the most out of Jekyll. File all bugs/feature requests at [Jekyll’s GitHub repo][jekyll-gh]. If you have questions, you can ask them on [Jekyll Talk][jekyll-talk].

[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
